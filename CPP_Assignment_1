{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "a50e704f",
   "metadata": {},
   "source": [
    "# Week 1: Percolation theory "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "126d49bd",
   "metadata": {},
   "source": [
    "Welcome to CPP! This is the jupyter notebook for the tasks of the first week. In this notebook, we will: \n",
    "1) Initialise a system \n",
    "2) Identify the clusters in the system \n",
    "3) Analyse various properties such as average size, probability of percolating, etc. \n",
    "\n",
    "I have added descriptions, links and hints; this assignment has been made such that google, stackexchange, and python documentation should be more than enough to do this easily. While I cannot control what you do, I encourage you to not go to LLMs to do these tasks. They are easy enough and are instructive and will help you learn more python, which vibecoding will not.\n",
    "\n",
    "I will also encourage you to comment your code if you get time; it will help when you look back at the code when you are making your report. \n",
    "\n",
    "Feel free to ask doubts in the group or in my DMs! "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "imports",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.colors as mcolors\n",
    "from collections import defaultdict\n",
    "\n",
    "%matplotlib inline\n",
    "plt.rcParams['figure.dpi'] = 100"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "73c1fe5f",
   "metadata": {},
   "source": [
    "## 1. Initialising the system\n",
    "\n",
    "In the cell below, write a function which takes in two values: $n$, which is the length of the square grid we are making, and $p$ which is the probability that a square is filled (or black), and returns a 2D array which will be our grid.\n",
    "\n",
    "Hint: np.random.rand"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b7781eb8",
   "metadata": {},
   "outputs": [],
   "source": [
    "def initialise_grid(n, p):\n",
    "    \"\"\"\n",
    "    Create an n x n grid where each site is occupied (True)\n",
    "    with probability p, and empty (False) otherwise.\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    n : int   -- side length of the square grid\n",
    "    p : float -- probability that a site is occupied\n",
    "\n",
    "    Returns\n",
    "    -------\n",
    "    grid : 2D numpy bool array, shape (n, n)\n",
    "        grid[i, j] = True  -> site (i, j) is occupied\n",
    "        grid[i, j] = False -> site (i, j) is empty\n",
    "    \"\"\"\n",
    "    # np.random.rand(n, n) draws n*n uniform samples from [0, 1).\n",
    "    # Comparing with p gives True with probability p.\n",
    "    return np.random.rand(n, n) < p\n",
    "\n",
    "\n",
    "# Quick test\n",
    "np.random.seed(0)\n",
    "test_grid = initialise_grid(5, 0.5)\n",
    "print(\"Test grid (5x5, p=0.5):\")\n",
    "print(test_grid.astype(int))\n",
    "print(f\"Fraction occupied: {test_grid.mean():.2f}  (expected ~0.5)\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3c074696",
   "metadata": {},
   "source": [
    "## 2. Identifying and Labelling clusters: Hoshen–Kopelman algorithm\n",
    "\n",
    "From the previous section you now have a 2D numpy array which is a grid with `True` and `False` values. Your task now is to write a function that scans the grid and assigns a unique integer label to each connected cluster of occupied sites.\n",
    "\n",
    "A cluster is defined as a group of occupied sites that are connected to each other through nearest neighbours (up, down, left, right). \n",
    "\n",
    "Define a function, which takes in the 2D array as input, and returns a new array `labels` of the same shape, where:\n",
    "\n",
    "1) `labels[i, j] = 0` if the site is empty\n",
    "2) `labels[i, j] = k` if the site belongs to cluster $k$\n",
    "\n",
    "Clusters that are connected (via nearest neighbours) must have the same label. This is the hardest part of the assignment.\n",
    "\n",
    "You can learn more about this algorithm in the following link: https://en.wikipedia.org/wiki/Hoshen%E2%80%93Kopelman_algorithm\n",
    "\n",
    "### Algorithm outline\n",
    "The algorithm works in two passes combined with a **Union-Find** (disjoint-set) data structure:\n",
    "\n",
    "1. **First pass (left-to-right, top-to-bottom):** For each occupied site, look at the already-visited neighbours (left and top). Assign labels and merge clusters that turn out to be connected via the Union-Find `union` operation.\n",
    "2. **Second pass:** Replace every provisional label with the root of its Union-Find tree (the canonical label for its cluster).\n",
    "3. **Relabel:** Remap the canonical labels to consecutive integers $1, 2, 3, \\ldots$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3cec80d0",
   "metadata": {},
   "outputs": [],
   "source": [
    "# --- Union-Find helpers ---\n",
    "\n",
    "def find(uf, x):\n",
    "    \"\"\"Path-compressed find: return root of element x in Union-Find array uf.\"\"\"\n",
    "    while uf[x] != x:\n",
    "        uf[x] = uf[uf[x]]   # path-halving compression\n",
    "        x = uf[x]\n",
    "    return x\n",
    "\n",
    "\n",
    "def union(uf, x, y):\n",
    "    \"\"\"Merge the sets containing x and y in Union-Find array uf.\"\"\"\n",
    "    rx, ry = find(uf, x), find(uf, y)\n",
    "    if rx != ry:\n",
    "        uf[ry] = rx   # attach ry's tree under rx\n",
    "\n",
    "\n",
    "# --- Main labelling function ---\n",
    "\n",
    "def hoshen_kopelman(grid):\n",
    "    \"\"\"\n",
    "    Label every connected cluster of occupied sites in `grid` with a\n",
    "    unique positive integer using the Hoshen-Kopelman algorithm.\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    grid : 2D bool numpy array\n",
    "        True  -> occupied site\n",
    "        False -> empty site\n",
    "\n",
    "    Returns\n",
    "    -------\n",
    "    labels : 2D int numpy array (same shape as grid)\n",
    "        0 -> empty site\n",
    "        k -> site belongs to cluster k  (k >= 1, consecutive)\n",
    "    \"\"\"\n",
    "    n = grid.shape[0]\n",
    "    labels = np.zeros((n, n), dtype=int)\n",
    "\n",
    "    # Union-Find array; uf[i] = i means i is its own root\n",
    "    max_possible = n * n + 1\n",
    "    uf = np.arange(max_possible, dtype=int)\n",
    "\n",
    "    next_label = 1  # counter for fresh cluster labels\n",
    "\n",
    "    # -------- First pass --------\n",
    "    for i in range(n):\n",
    "        for j in range(n):\n",
    "            if not grid[i, j]:\n",
    "                continue  # skip empty sites\n",
    "\n",
    "            # Neighbours already visited: left (i, j-1) and top (i-1, j)\n",
    "            left = labels[i, j - 1] if j > 0 and grid[i, j - 1] else 0\n",
    "            top  = labels[i - 1, j] if i > 0 and grid[i - 1, j] else 0\n",
    "\n",
    "            if left == 0 and top == 0:\n",
    "                # No occupied neighbours: start a new cluster\n",
    "                labels[i, j] = next_label\n",
    "                next_label += 1\n",
    "            elif left != 0 and top == 0:\n",
    "                # Only left neighbour: inherit its cluster\n",
    "                labels[i, j] = find(uf, left)\n",
    "            elif left == 0 and top != 0:\n",
    "                # Only top neighbour: inherit its cluster\n",
    "                labels[i, j] = find(uf, top)\n",
    "            else:\n",
    "                # Both neighbours occupied: merge their clusters\n",
    "                union(uf, left, top)\n",
    "                labels[i, j] = find(uf, left)\n",
    "\n",
    "    # -------- Second pass: resolve all labels to their roots --------\n",
    "    for i in range(n):\n",
    "        for j in range(n):\n",
    "            if labels[i, j] > 0:\n",
    "                labels[i, j] = find(uf, labels[i, j])\n",
    "\n",
    "    # -------- Relabel to consecutive integers 1, 2, 3, ... --------\n",
    "    unique = np.unique(labels[labels > 0])        # non-zero canonical labels\n",
    "    remap  = {old: new for new, old in enumerate(unique, start=1)}\n",
    "    remap[0] = 0                                   # keep empty sites as 0\n",
    "    vec_remap = np.vectorize(remap.get)\n",
    "    labels = vec_remap(labels)\n",
    "\n",
    "    return labels\n",
    "\n",
    "\n",
    "# Quick test\n",
    "np.random.seed(42)\n",
    "g = initialise_grid(8, 0.6)\n",
    "lbl = hoshen_kopelman(g)\n",
    "print(\"Grid (8x8, p=0.6):\")\n",
    "print(g.astype(int))\n",
    "print(\"\\nCluster labels:\")\n",
    "print(lbl)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "01d84c35",
   "metadata": {},
   "source": [
    "## 3. Check if the system percolated \n",
    "\n",
    "Check if the system has percolated or not by checking if there is a cluster label appearing on opposite edges of the system. No hints for this one! "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0438f357",
   "metadata": {},
   "outputs": [],
   "source": [
    "def check_percolation(labels):\n",
    "    \"\"\"\n",
    "    Determine whether the lattice percolates vertically\n",
    "    (i.e. a cluster spans from the top row to the bottom row).\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    labels : 2D int numpy array (output of hoshen_kopelman)\n",
    "\n",
    "    Returns\n",
    "    -------\n",
    "    percolates   : bool   -- True if a spanning cluster exists\n",
    "    perc_cluster : int    -- label of the percolating cluster (0 if none)\n",
    "    \"\"\"\n",
    "    # Collect all non-zero cluster labels in the top and bottom rows\n",
    "    top_labels    = set(labels[0,  :]) - {0}   # top row\n",
    "    bottom_labels = set(labels[-1, :]) - {0}   # bottom row\n",
    "\n",
    "    # A cluster percolates if its label appears in BOTH rows\n",
    "    spanning = top_labels & bottom_labels\n",
    "\n",
    "    if spanning:\n",
    "        # Return the smallest spanning label (arbitrary, but deterministic)\n",
    "        return True, min(spanning)\n",
    "    return False, 0\n",
    "\n",
    "\n",
    "# Test on the 8x8 grid from above\n",
    "perc, pc = check_percolation(lbl)\n",
    "print(f\"Percolates: {perc}  |  Percolating cluster label: {pc}\")\n",
    "\n",
    "# Also test at a high probability where it almost always percolates\n",
    "np.random.seed(7)\n",
    "g_high = initialise_grid(20, 0.8)\n",
    "lbl_high = hoshen_kopelman(g_high)\n",
    "perc2, pc2 = check_percolation(lbl_high)\n",
    "print(f\"High-p grid: Percolates: {perc2}  |  Cluster: {pc2}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c01c4fc1",
   "metadata": {},
   "source": [
    "## 4. Visualise your grid! \n",
    "\n",
    "Visualisation is very important; it is very useful while debugging, also gives physical insights. Hint: use matplotlib's `matshow` to plot your grid along with the label of the cluster. You can also colour code the labels too! Check out the various colourmaps matplotlib has to offer. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9ac8cb6b",
   "metadata": {},
   "outputs": [],
   "source": [
    "def visualise_grid(grid, labels, title=\"Percolation Grid\"):\n",
    "    \"\"\"\n",
    "    Side-by-side visualisation:\n",
    "      Left  panel: binary occupied/empty grid (black/white)\n",
    "      Right panel: cluster-labelled grid with each cluster in a distinct colour.\n",
    "                   The percolating cluster (if any) gets a bright red highlight.\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    grid   : 2D bool array\n",
    "    labels : 2D int array (from hoshen_kopelman)\n",
    "    title  : str, optional\n",
    "    \"\"\"\n",
    "    percolates, pc = check_percolation(labels)\n",
    "    n_clusters = int(labels.max())\n",
    "\n",
    "    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))\n",
    "\n",
    "    # ---- Left: raw binary grid ----\n",
    "    ax1.matshow(grid.astype(int), cmap='binary', vmin=0, vmax=1)\n",
    "    ax1.set_title(\"Binary grid (black = occupied)\", pad=8)\n",
    "    ax1.axis('off')\n",
    "\n",
    "    # ---- Right: colour-coded cluster labels ----\n",
    "    # Build a ListedColormap: index 0 -> white (empty), index k -> some colour\n",
    "    cmap_base = plt.colormaps.get_cmap('tab20')\n",
    "    colors = [(1.0, 1.0, 1.0, 1.0)]   # white for label 0\n",
    "    for k in range(1, n_clusters + 1):\n",
    "        if percolates and k == pc:\n",
    "            colors.append((0.9, 0.1, 0.1, 1.0))   # bright red for percolating cluster\n",
    "        else:\n",
    "            colors.append(cmap_base(k % 20))\n",
    "    cmap_labels = mcolors.ListedColormap(colors)\n",
    "\n",
    "    im = ax2.matshow(labels, cmap=cmap_labels, vmin=0, vmax=max(n_clusters, 1))\n",
    "    ax2.set_title(f\"Cluster labels ({n_clusters} clusters)\", pad=8)\n",
    "    ax2.axis('off')\n",
    "    plt.colorbar(im, ax=ax2, fraction=0.046, pad=0.04, label='Cluster label')\n",
    "\n",
    "    perc_str = f\"PERCOLATES (cluster {pc}, shown in red)\" if percolates else \"Does NOT percolate\"\n",
    "    fig.suptitle(f\"{title}  |  {perc_str}\", fontsize=12, y=1.01)\n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "\n",
    "\n",
    "# Visualise a 20x20 grid near the critical point\n",
    "np.random.seed(123)\n",
    "g_vis  = initialise_grid(20, 0.59)\n",
    "lbl_vis = hoshen_kopelman(g_vis)\n",
    "visualise_grid(g_vis, lbl_vis, title=\"n=20, p=0.59 (near critical)\")\n",
    "\n",
    "# And one clearly above the threshold\n",
    "np.random.seed(7)\n",
    "g_vis2   = initialise_grid(20, 0.75)\n",
    "lbl_vis2 = hoshen_kopelman(g_vis2)\n",
    "visualise_grid(g_vis2, lbl_vis2, title=\"n=20, p=0.75 (above critical)\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "79a6f4db",
   "metadata": {},
   "source": [
    "### Analysis time! \n",
    "\n",
    "That's all the prep needed! Now for squares of length 8, 16 and 32, find the following as a function of $p$:\n",
    "\n",
    "1) **Weighted average cluster size** $S(p)$: If the system is percolating, do not count the percolating cluster.\n",
    "2) **Percolation strength** $P_\\infty(p)$: size of the percolating cluster divided by the total number of sites. If the system does not percolate, this value is 0.\n",
    "3) **Percolation rate** $\\Pi(p)$: probability that the system will percolate.\n",
    "\n",
    "Initialise $N$ number of systems and average over them to get probability. Plot these three using matplotlib. Based on these plots, give comments regarding your observations. If you see a phase transition, can you estimate its critical probability? \n",
    "   \n",
    "Reference: https://www.mit.edu/~levitov/8.334/notes/percol_notes.pdf"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d33c025e",
   "metadata": {},
   "outputs": [],
   "source": [
    "def cluster_sizes(labels):\n",
    "    \"\"\"\n",
    "    Return a dict {cluster_label: number_of_sites} for all non-zero labels.\n",
    "    \"\"\"\n",
    "    sizes = defaultdict(int)\n",
    "    for v in labels.flat:\n",
    "        if v > 0:\n",
    "            sizes[v] += 1\n",
    "    return dict(sizes)\n",
    "\n",
    "\n",
    "def compute_observables(n, p, N_trials=300):\n",
    "    \"\"\"\n",
    "    Run N_trials independent realisations of an n x n lattice at\n",
    "    occupation probability p and return Monte-Carlo averages of:\n",
    "\n",
    "    mean_S  : weighted average cluster size (2nd / 1st moment of cluster-size\n",
    "              distribution), excluding the percolating cluster when present.\n",
    "              S = sum_s (s^2 * n_s) / sum_s (s * n_s)\n",
    "\n",
    "    P_inf   : percolation strength = (size of percolating cluster) / n^2,\n",
    "              averaged over all trials. Zero for trials with no percolation.\n",
    "\n",
    "    pi_p    : percolation probability = fraction of trials that percolate.\n",
    "    \"\"\"\n",
    "    total_S    = 0.0\n",
    "    total_Pinf = 0.0\n",
    "    perc_count = 0\n",
    "    system_size = n * n\n",
    "\n",
    "    for _ in range(N_trials):\n",
    "        grid   = initialise_grid(n, p)\n",
    "        labels = hoshen_kopelman(grid)\n",
    "        percolates, pc_label = check_percolation(labels)\n",
    "\n",
    "        sizes = cluster_sizes(labels)   # {label: size}\n",
    "\n",
    "        if percolates:\n",
    "            perc_count += 1\n",
    "            perc_size   = sizes.pop(pc_label, 0)   # remove percolating cluster\n",
    "            total_Pinf += perc_size / system_size\n",
    "\n",
    "        # Weighted average cluster size from remaining clusters\n",
    "        if sizes:\n",
    "            vals  = np.array(list(sizes.values()), dtype=float)\n",
    "            total_S += np.dot(vals, vals) / vals.sum()   # sum(s^2 n_s) / sum(s n_s)\n",
    "        # If no non-percolating clusters remain, contribution is 0\n",
    "\n",
    "    return total_S / N_trials, total_Pinf / N_trials, perc_count / N_trials"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8e278e9a",
   "metadata": {},
   "outputs": [],
   "source": [
    "# --- Run the Monte Carlo analysis ---\n",
    "\n",
    "p_values   = np.linspace(0.0, 1.0, 51)   # 51 evenly spaced p values from 0 to 1\n",
    "grid_sizes = [8, 16, 32]\n",
    "N_trials   = 300\n",
    "\n",
    "results = {}   # results[n] = {'S': [...], 'Pinf': [...], 'pi': [...]}\n",
    "\n",
    "for n in grid_sizes:\n",
    "    print(f\"Running n = {n} ...\")\n",
    "    S_list, Pinf_list, pi_list = [], [], []\n",
    "    for p in p_values:\n",
    "        S, Pinf, pi = compute_observables(n, p, N_trials)\n",
    "        S_list.append(S)\n",
    "        Pinf_list.append(Pinf)\n",
    "        pi_list.append(pi)\n",
    "    results[n] = {'S': S_list, 'Pinf': Pinf_list, 'pi': pi_list}\n",
    "    print(f\"  Done.\")\n",
    "\n",
    "print(\"\\nAnalysis complete!\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ad4c70db",
   "metadata": {},
   "outputs": [],
   "source": [
    "# --- Plot all three observables ---\n",
    "\n",
    "colors     = ['#e74c3c', '#2980b9', '#27ae60']   # red, blue, green for n=8,16,32\n",
    "linestyles = ['-', '--', ':']\n",
    "\n",
    "fig, axes = plt.subplots(1, 3, figsize=(16, 5))\n",
    "fig.suptitle(\n",
    "    \"Site Percolation on a 2D Square Lattice\",\n",
    "    fontsize=14, fontweight='bold'\n",
    ")\n",
    "\n",
    "# Known exact critical probability for 2D square lattice site percolation\n",
    "p_c = 0.5927\n",
    "\n",
    "# ---- Panel 1: Weighted average cluster size ----\n",
    "ax = axes[0]\n",
    "for n, c, ls in zip(grid_sizes, colors, linestyles):\n",
    "    ax.plot(p_values, results[n]['S'], label=f'n = {n}', color=c, ls=ls, lw=2)\n",
    "ax.axvline(p_c, color='gray', ls='--', lw=1.2, alpha=0.8, label=r'$p_c \\approx 0.593$')\n",
    "ax.set_xlabel('Occupation probability $p$', fontsize=12)\n",
    "ax.set_ylabel('Weighted avg. cluster size $S(p)$', fontsize=12)\n",
    "ax.set_title('Average Cluster Size $S(p)$', fontsize=12)\n",
    "ax.legend(fontsize=10)\n",
    "ax.grid(True, alpha=0.3)\n",
    "\n",
    "# ---- Panel 2: Percolation strength ----\n",
    "ax = axes[1]\n",
    "for n, c, ls in zip(grid_sizes, colors, linestyles):\n",
    "    ax.plot(p_values, results[n]['Pinf'], label=f'n = {n}', color=c, ls=ls, lw=2)\n",
    "ax.axvline(p_c, color='gray', ls='--', lw=1.2, alpha=0.8, label=r'$p_c \\approx 0.593$')\n",
    "ax.set_xlabel('Occupation probability $p$', fontsize=12)\n",
    "ax.set_ylabel(r'Percolation strength $P_\\infty(p)$', fontsize=12)\n",
    "ax.set_title(r'Percolation Strength $P_\\infty(p)$', fontsize=12)\n",
    "ax.legend(fontsize=10)\n",
    "ax.grid(True, alpha=0.3)\n",
    "\n",
    "# ---- Panel 3: Percolation probability ----\n",
    "ax = axes[2]\n",
    "for n, c, ls in zip(grid_sizes, colors, linestyles):\n",
    "    ax.plot(p_values, results[n]['pi'], label=f'n = {n}', color=c, ls=ls, lw=2)\n",
    "ax.axvline(p_c, color='gray', ls='--', lw=1.2, alpha=0.8, label=r'$p_c \\approx 0.593$')\n",
    "ax.set_xlabel('Occupation probability $p$', fontsize=12)\n",
    "ax.set_ylabel(r'Percolation probability $\\Pi(p)$', fontsize=12)\n",
    "ax.set_title(r'Percolation Rate $\\Pi(p)$', fontsize=12)\n",
    "ax.legend(fontsize=10)\n",
    "ax.grid(True, alpha=0.3)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d1376168",
   "metadata": {},
   "outputs": [],
   "source": [
    "# --- Comments on observations ---\n",
    "print(\"\"\"\n",
    "OBSERVATIONS\n",
    "============\n",
    "\n",
    "1. Weighted Average Cluster Size S(p)\n",
    "   - For p well below the critical probability p_c ~ 0.593, clusters are\n",
    "     small and isolated.  S(p) is correspondingly small.\n",
    "   - S(p) shows a pronounced peak near p_c.  This peak is the signature of\n",
    "     the percolation phase transition: right at the critical point, clusters\n",
    "     of all sizes co-exist, leading to a divergence of the average cluster\n",
    "     size in the infinite-system limit.\n",
    "   - The peak sharpens and grows taller as n increases, reflecting finite-\n",
    "     size scaling: the true divergence is only recovered in the limit n -> inf.\n",
    "   - For p >> p_c, a single giant spanning cluster dominates (excluded from\n",
    "     the average), so S drops back towards small values.\n",
    "\n",
    "2. Percolation Strength P_inf(p)\n",
    "   - P_inf = 0 for p < p_c: no spanning cluster exists.\n",
    "   - At p_c it switches on and grows continuously towards 1 as p -> 1.\n",
    "   - This is an order parameter for the percolation transition, analogous\n",
    "     to magnetisation in a ferromagnet.  The transition is continuous\n",
    "     (second-order): P_inf turns on smoothly rather than jumping.\n",
    "   - Larger n makes the onset sharper (closer to a step function).\n",
    "\n",
    "3. Percolation Probability Pi(p)\n",
    "   - Pi(p) is an S-shaped (sigmoidal) curve that rises from 0 to 1 around p_c.\n",
    "   - The transition becomes steeper with increasing n, converging to a\n",
    "     Heaviside step function in the infinite-system limit.\n",
    "   - This directly illustrates finite-size rounding of the phase transition.\n",
    "\n",
    "4. Critical Probability Estimate\n",
    "   - All three observables signal p_c ~ 0.59-0.60, consistent with the\n",
    "     exact value p_c = 0.5927... for 2D square-lattice site percolation.\n",
    "   - The estimate improves (sharpens) as n grows.\n",
    "\"\"\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bef878e7",
   "metadata": {},
   "source": [
    "## Bonus: Bethe lattice\n",
    "\n",
    "Read about the Bethe lattice: https://en.wikipedia.org/wiki/Bethe_lattice \n",
    "\n",
    "Can you find its critical probability? It's a very neat answer and does not require code. "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "619a1f15",
   "metadata": {},
   "source": [
    "### Bethe Lattice Critical Probability\n",
    "\n",
    "The **Bethe lattice** (or Cayley tree) is an infinite tree in which every node has exactly $z$ neighbours (coordination number $z$). Being a tree, there are no loops — every pair of sites is connected by exactly one path.\n",
    "\n",
    "**Exact result:**\n",
    "\n",
    "$$\\boxed{p_c = \\frac{1}{z - 1}}$$\n",
    "\n",
    "**Derivation sketch:**  \n",
    "Consider whether the cluster connected to a given site is infinite. For this to happen, at least one of the $z-1$ child branches emanating from a neighbour must itself contain an infinite cluster (the $z-1$ rather than $z$ arises because one of the $z$ edges points \"back\" toward the root). Let $Q$ be the probability that a branch does *not* lead to an infinite cluster. Self-consistency requires:\n",
    "\n",
    "$$Q = (1-p) + p\\,Q^{z-1}$$\n",
    "\n",
    "The trivial solution $Q = 1$ (no infinite cluster) becomes unstable exactly when the linearisation around $Q=1$ yields a slope $\\geq 1$, i.e. when $p(z-1) \\geq 1$. This gives the critical condition:\n",
    "\n",
    "$$p_c = \\frac{1}{z-1}$$\n",
    "\n",
    "**Specific cases:**\n",
    "\n",
    "| Coordination number $z$ | $p_c = 1/(z-1)$ |\n",
    "|:-:|:-:|\n",
    "| 3 | 1/2 |\n",
    "| 4 | 1/3 |\n",
    "| 5 | 1/4 |\n",
    "\n",
    "This is an elegant, analytically exact result — **no simulation needed**. It also provides an upper bound for the critical probability on any lattice with the same coordination number, since loops in real lattices make percolation easier (lower $p_c$). For example, the 2D square lattice has $z=4$ and $p_c^{\\text{Bethe}} = 1/3$, while the actual value is $p_c \\approx 0.593$."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5a81ca58",
   "metadata": {},
   "source": [
    "## Bonus 2.0: Bond percolation \n",
    "\n",
    "Find what bond percolation is and try out the above tasks for 2D lattice but with bonds instead of filled/unfilled sites. This is trickier though, so try this if you have time. Is the critical probability same or different? "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "19d7333c",
   "metadata": {},
   "outputs": [],
   "source": [
    "# ============================================================\n",
    "# BONUS 2: Bond Percolation\n",
    "# ============================================================\n",
    "# In SITE percolation, each site (node) is independently occupied\n",
    "# with probability p.\n",
    "#\n",
    "# In BOND percolation, each EDGE (bond) connecting two nearest-\n",
    "# neighbour sites is independently open with probability p.\n",
    "# All sites are present; connectivity is determined solely by the\n",
    "# open/closed status of the bonds.\n",
    "#\n",
    "# For the 2D square lattice, the exact critical threshold is:\n",
    "#   p_c^{bond} = 0.5  (exactly 1/2, by self-duality of the square lattice)\n",
    "# This is lower than the site threshold p_c^{site} ≈ 0.5927.\n",
    "# ============================================================\n",
    "\n",
    "def initialise_bond_grid(n, p):\n",
    "    \"\"\"\n",
    "    Create bond arrays for bond percolation on an n x n lattice.\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    n : int   -- lattice side length\n",
    "    p : float -- probability that each bond is open\n",
    "\n",
    "    Returns\n",
    "    -------\n",
    "    h_bonds : bool array, shape (n, n-1)\n",
    "        h_bonds[i, j] = True  ->  horizontal bond between sites (i,j) and (i,j+1) is open\n",
    "    v_bonds : bool array, shape (n-1, n)\n",
    "        v_bonds[i, j] = True  ->  vertical bond between sites (i,j) and (i+1,j) is open\n",
    "    \"\"\"\n",
    "    h_bonds = np.random.rand(n, n - 1) < p   # n*(n-1) horizontal bonds\n",
    "    v_bonds = np.random.rand(n - 1, n) < p   # (n-1)*n vertical bonds\n",
    "    return h_bonds, v_bonds\n",
    "\n",
    "\n",
    "def bond_hoshen_kopelman(n, h_bonds, v_bonds):\n",
    "    \"\"\"\n",
    "    Label connected clusters for bond percolation using Union-Find.\n",
    "    Every site starts in its own cluster; open bonds merge clusters.\n",
    "\n",
    "    Returns a labels array identical in format to the site-percolation version.\n",
    "    \"\"\"\n",
    "    # Assign each site a provisional label = its flat index + 1\n",
    "    labels = np.arange(1, n * n + 1, dtype=int).reshape(n, n)\n",
    "\n",
    "    # Union-Find array (index 0 unused as sentinel)\n",
    "    uf = np.arange(n * n + 1, dtype=int)\n",
    "\n",
    "    def find_b(x):\n",
    "        while uf[x] != x:\n",
    "            uf[x] = uf[uf[x]]\n",
    "            x = uf[x]\n",
    "        return x\n",
    "\n",
    "    def union_b(x, y):\n",
    "        rx, ry = find_b(x), find_b(y)\n",
    "        if rx != ry:\n",
    "            uf[ry] = rx\n",
    "\n",
    "    # Merge via horizontal bonds\n",
    "    for i in range(n):\n",
    "        for j in range(n - 1):\n",
    "            if h_bonds[i, j]:\n",
    "                union_b(labels[i, j], labels[i, j + 1])\n",
    "\n",
    "    # Merge via vertical bonds\n",
    "    for i in range(n - 1):\n",
    "        for j in range(n):\n",
    "            if v_bonds[i, j]:\n",
    "                union_b(labels[i, j], labels[i + 1, j])\n",
    "\n",
    "    # Flatten all labels to their roots\n",
    "    result = np.array([[find_b(labels[i, j]) for j in range(n)] for i in range(n)])\n",
    "\n",
    "    # Relabel consecutively\n",
    "    unique  = np.unique(result)\n",
    "    remap   = {old: new for new, old in enumerate(unique, start=1)}\n",
    "    result  = np.vectorize(remap.get)(result)\n",
    "    return result\n",
    "\n",
    "\n",
    "def compute_bond_observables(n, p, N_trials=300):\n",
    "    \"\"\"Same observables as site percolation but for bond percolation.\"\"\"\n",
    "    total_S    = 0.0\n",
    "    total_Pinf = 0.0\n",
    "    perc_count = 0\n",
    "    system_size = n * n\n",
    "\n",
    "    for _ in range(N_trials):\n",
    "        h_bonds, v_bonds = initialise_bond_grid(n, p)\n",
    "        labels = bond_hoshen_kopelman(n, h_bonds, v_bonds)\n",
    "        percolates, pc_label = check_percolation(labels)\n",
    "\n",
    "        sizes = cluster_sizes(labels)\n",
    "\n",
    "        if percolates:\n",
    "            perc_count += 1\n",
    "            perc_size   = sizes.pop(pc_label, 0)\n",
    "            total_Pinf += perc_size / system_size\n",
    "\n",
    "        if sizes:\n",
    "            vals = np.array(list(sizes.values()), dtype=float)\n",
    "            total_S += np.dot(vals, vals) / vals.sum()\n",
    "\n",
    "    return total_S / N_trials, total_Pinf / N_trials, perc_count / N_trials\n",
    "\n",
    "\n",
    "# Run bond percolation analysis for n = 16 and 32\n",
    "bond_results = {}\n",
    "for n in [16, 32]:\n",
    "    print(f\"Running bond percolation n = {n} ...\")\n",
    "    S_list, Pinf_list, pi_list = [], [], []\n",
    "    for p in p_values:\n",
    "        S, Pinf, pi = compute_bond_observables(n, p, N_trials=300)\n",
    "        S_list.append(S)\n",
    "        Pinf_list.append(Pinf)\n",
    "        pi_list.append(pi)\n",
    "    bond_results[n] = {'S': S_list, 'Pinf': Pinf_list, 'pi': pi_list}\n",
    "    print(f\"  Done.\")\n",
    "\n",
    "print(\"Bond percolation analysis complete!\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bond_plots",
   "metadata": {},
   "outputs": [],
   "source": [
    "# --- Compare site vs bond percolation ---\n",
    "\n",
    "fig, axes = plt.subplots(1, 3, figsize=(16, 5))\n",
    "fig.suptitle(\"Site vs Bond Percolation (n = 32)\", fontsize=14, fontweight='bold')\n",
    "\n",
    "p_c_site = 0.5927   # exact for 2D square lattice site percolation\n",
    "p_c_bond = 0.5000   # exact for 2D square lattice bond percolation (self-duality)\n",
    "\n",
    "labels_plot = ['Average Cluster Size', 'Percolation Strength', 'Percolation Rate']\n",
    "keys        = ['S', 'Pinf', 'pi']\n",
    "ylabels     = [r'$S(p)$', r'$P_\\infty(p)$', r'$\\Pi(p)$']\n",
    "\n",
    "for ax, key, ylabel, title in zip(axes, keys, ylabels, labels_plot):\n",
    "    ax.plot(p_values, results[32][key],      color='#2980b9', lw=2,       label='Site  n=32')\n",
    "    ax.plot(p_values, bond_results[32][key], color='#e74c3c', lw=2, ls='--', label='Bond  n=32')\n",
    "    ax.axvline(p_c_site, color='#2980b9', ls=':', lw=1.3, alpha=0.8,\n",
    "               label=rf'Site $p_c\\approx{p_c_site}$')\n",
    "    ax.axvline(p_c_bond, color='#e74c3c', ls=':', lw=1.3, alpha=0.8,\n",
    "               label=rf'Bond $p_c = {p_c_bond}$')\n",
    "    ax.set_xlabel('Occupation / bond probability $p$', fontsize=11)\n",
    "    ax.set_ylabel(ylabel, fontsize=12)\n",
    "    ax.set_title(title, fontsize=12)\n",
    "    ax.legend(fontsize=9)\n",
    "    ax.grid(True, alpha=0.3)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "32a401ca",
   "metadata": {},
   "source": [
    "### Bond percolation — Comments\n",
    "\n",
    "**What is bond percolation?**  \n",
    "In *site* percolation, each node is independently present with probability $p$.  In *bond* percolation, all nodes are always present, but each *edge* (bond) between neighbouring nodes is independently open with probability $p$. Two sites belong to the same cluster if and only if there is a path connecting them using only open bonds.\n",
    "\n",
    "**Critical probability comparison for the 2D square lattice:**\n",
    "\n",
    "| Type | $p_c$ | Method |\n",
    "|------|-------|--------|\n",
    "| Site | $\\approx 0.5927$ | Numerical (exact value not known in closed form) |\n",
    "| Bond | $= 0.5000$ | Exact, by self-duality of the square lattice |\n",
    "\n",
    "**Why is $p_c^{\\text{bond}} < p_c^{\\text{site}}$?**  \n",
    "Heuristically, in site percolation a site must be occupied for *any* of its bonds to contribute to connectivity.  Removing a site severs all $z=4$ bonds simultaneously.  In bond percolation, a single bond can be open regardless of others.  It is therefore easier (at a given $p$) for a spanning path to form through bonds, which is why the threshold is lower.\n",
    "\n",
    "**Self-duality argument for $p_c^{\\text{bond}} = 1/2$:**  \n",
    "The square lattice is its own dual (the dual of a square lattice is another square lattice, offset by half a lattice constant).  A bond configuration percolates from left to right if and only if its *dual* (complementary) configuration does *not* percolate from top to bottom.  By symmetry, these two events have the same probability when $p = 1 - p$, i.e. at $p = 1/2$.  This pins the critical point exactly at $p_c = 1/2$."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "name": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
